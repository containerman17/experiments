State Diffs - Removed due to performance impact
===============================================

State diffs via debug_traceTransaction with prestateTracer are too slow for historical sync.
Can be re-added later when catching up to tip or for specific use cases.

Types (from rpc/types.go):
--------------------------

// StateDiff from prestateTracer with diffMode: true
type StateDiff struct {
	Pre  map[string]*AccountState `json:"pre"`
	Post map[string]*AccountState `json:"post"`
}

type AccountState struct {
	Balance string            `json:"balance,omitempty"`
	Nonce   uint64            `json:"nonce,omitempty"`
	Code    string            `json:"code,omitempty"`
	Storage map[string]string `json:"storage,omitempty"`
}

type StateDiffResult struct {
	TxHash string     `json:"txHash"`
	Result *StateDiff `json:"result"`
}

// In NormalizedBlock:
StateDiffs []StateDiffResult `json:"stateDiffs"`


Fetcher function (from rpc/fetcher.go):
---------------------------------------

// fetchStateDiffsBatch fetches state diffs for transactions using prestateTracer with diffMode
func (f *Fetcher) fetchStateDiffsBatch(ctx context.Context, txInfos []txInfo) (map[string]*StateDiffResult, error) {
	stateDiffsMap := make(map[string]*StateDiffResult)
	var mu sync.Mutex

	var txRequests []JSONRPCRequest
	txHashToIdx := make(map[int]string)

	for i, tx := range txInfos {
		txRequests = append(txRequests, JSONRPCRequest{
			Jsonrpc: "2.0",
			Method:  "debug_traceTransaction",
			Params: []interface{}{
				tx.hash,
				map[string]interface{}{
					"tracer":       "prestateTracer",
					"tracerConfig": map[string]bool{"diffMode": true},
				},
			},
			ID: i,
		})
		txHashToIdx[i] = tx.hash
	}

	txBatches := chunksOf(txRequests, f.debugBatchSize)
	var wg sync.WaitGroup
	var batchErr error

	for batchIdx, batch := range txBatches {
		wg.Add(1)
		go func(idx int, requests []JSONRPCRequest) {
			defer wg.Done()

			var responses []JSONRPCResponse
			var err error

			for attempt := 0; attempt <= f.maxRetries; attempt++ {
				if attempt > 0 {
					delay := f.retryDelay * time.Duration(1<<uint(attempt-1))
					if delay > 10*time.Second {
						delay = 10 * time.Second
					}
					time.Sleep(delay)
				}

				err = f.controller.Execute(ctx, func() error {
					var innerErr error
					responses, innerErr = f.batchRpcCallDebug(ctx, requests)
					return innerErr
				})

				if err != nil {
					continue
				}

				hasRetryableError := false
				for _, resp := range responses {
					if resp.Error != nil && !isPrecompileError(resp.Error.Message) {
						hasRetryableError = true
						break
					}
				}

				if !hasRetryableError {
					break
				}
			}

			if err != nil {
				mu.Lock()
				if batchErr == nil {
					batchErr = fmt.Errorf("state diff batch %d failed after retries: %w", idx, err)
				}
				mu.Unlock()
				return
			}

			for _, resp := range responses {
				txHash := txHashToIdx[resp.ID]

				if resp.Error != nil {
					if isPrecompileError(resp.Error.Message) {
						mu.Lock()
						stateDiffsMap[txHash] = &StateDiffResult{TxHash: txHash, Result: nil}
						mu.Unlock()
						continue
					} else {
						mu.Lock()
						if batchErr == nil {
							batchErr = fmt.Errorf("state diff for tx %s failed: %s", txHash, resp.Error.Message)
						}
						mu.Unlock()
						return
					}
				}

				var stateDiff StateDiff
				if err := StrictUnmarshal(resp.Result, &stateDiff); err != nil {
					mu.Lock()
					if batchErr == nil {
						batchErr = fmt.Errorf("failed to parse state diff for tx %s: %w", txHash, err)
					}
					mu.Unlock()
					return
				}

				mu.Lock()
				stateDiffsMap[txHash] = &StateDiffResult{TxHash: txHash, Result: &stateDiff}
				mu.Unlock()
			}
		}(batchIdx, batch)
	}

	wg.Wait()
	if batchErr != nil {
		return nil, batchErr
	}
	return stateDiffsMap, nil
}


Usage in fetchSingleBlock:
--------------------------

// Fetch state diffs
var stateDiffsMap map[string]*StateDiffResult
if len(txInfos) > 0 {
	stateDiffsMap, err = f.fetchStateDiffsBatch(ctx, txInfos)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch state diffs: %w", err)
	}
} else {
	stateDiffsMap = make(map[string]*StateDiffResult)
}

// In assembly loop:
stateDiff, ok := stateDiffsMap[tx.Hash]
if ok && stateDiff != nil {
	stateDiffs[j] = *stateDiff
} else {
	stateDiffs[j] = StateDiffResult{TxHash: tx.Hash, Result: nil}
}

