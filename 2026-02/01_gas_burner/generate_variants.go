//go:build ignore

package main

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"golang.org/x/crypto/sha3"
)

const solTemplate = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
contract B {
    bytes32 public lastHash;
    function %s(uint256 iterations) external {
        bytes32 h = keccak256(abi.encodePacked(iterations));
        for (uint256 i = 0; i < iterations; ) {
            h = keccak256(abi.encodePacked(h));
            unchecked { ++i; }
        }
        lastHash = h;
    }
}
`

func randMethodName() string {
	var rb [8]byte
	rand.Read(rb[:])
	rb[0] = (rb[0] % 6) + 'a'
	return string(rb[0]) + hex.EncodeToString(rb[1:])
}

func selector(method string) [4]byte {
	h := sha3.NewLegacyKeccak256()
	h.Write([]byte(method + "(uint256)"))
	var s [4]byte
	copy(s[:], h.Sum(nil)[:4])
	return s
}

func main() {
	const n = 10
	tmp, _ := os.MkdirTemp("", "gasburner-gen")
	defer os.RemoveAll(tmp)

	type variant struct {
		name string
		sel  [4]byte
	}
	variants := make([]variant, n)

	for i := range n {
		name := randMethodName()
		variants[i] = variant{name: name, sel: selector(name)}
		path := filepath.Join(tmp, fmt.Sprintf("V%d.sol", i))
		os.WriteFile(path, []byte(fmt.Sprintf(solTemplate, name)), 0644)
	}

	outDir := filepath.Join(tmp, "out")
	os.MkdirAll(outDir, 0755)

	args := []string{"--abi", "--bin", "--optimize", "--optimize-runs", "200", "-o", outDir, "--overwrite"}
	for i := range n {
		args = append(args, filepath.Join(tmp, fmt.Sprintf("V%d.sol", i)))
	}
	cmd := exec.Command("solc", args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		panic(err)
	}

	var entries []string
	for i, v := range variants {
		bin, _ := os.ReadFile(filepath.Join(outDir, fmt.Sprintf("B.bin")))
		// solc outputs all as B.bin since contract name is B â€” compile one at a time
		// Actually let's just compile individually
		_ = bin
		_ = i
		_ = v
	}

	// Compile individually to avoid name collision (all contracts named B)
	entries = nil
	for i, v := range variants {
		iOut := filepath.Join(tmp, fmt.Sprintf("out%d", i))
		os.MkdirAll(iOut, 0755)
		solPath := filepath.Join(tmp, fmt.Sprintf("V%d.sol", i))
		cmd := exec.Command("solc", "--bin", "--optimize", "--optimize-runs", "200", "-o", iOut, "--overwrite", solPath)
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			panic(err)
		}
		bin, _ := os.ReadFile(filepath.Join(iOut, "B.bin"))
		sel := v.sel
		entries = append(entries, fmt.Sprintf(
			"\t{Bin: \"%s\", Selector: [4]byte{0x%02x, 0x%02x, 0x%02x, 0x%02x}}",
			strings.TrimSpace(string(bin)), sel[0], sel[1], sel[2], sel[3],
		))
	}

	goSrc := fmt.Sprintf(`// Code generated by generate_variants.go; DO NOT EDIT.

package burner

// Variant holds pre-compiled contract bytecode and its burn function selector.
type Variant struct {
	Bin      string  // hex deployment bytecode
	Selector [4]byte // 4-byte function selector for the burn method
}

// Variants contains %d GasBurner contract variants with unique undecodable method names.
var Variants = [%d]Variant{
%s,
}
`, n, n, strings.Join(entries, ",\n"))

	os.MkdirAll("burner", 0755)
	os.WriteFile("burner/variants.go", []byte(goSrc), 0644)
	fmt.Printf("Generated burner/variants.go with %d variants\n", n)
}
