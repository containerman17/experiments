package main

import (
	"context"
	"crypto/tls"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/ClickHouse/clickhouse-go/v2"
	"github.com/joho/godotenv"
)

func main() {
	godotenv.Overload()

	host := os.Getenv("CLICKHOUSE_HOST")
	user := os.Getenv("CLICKHOUSE_USER")
	password := os.Getenv("CLICKHOUSE_PASSWORD")

	if host == "" || user == "" {
		log.Fatal("CLICKHOUSE_HOST and CLICKHOUSE_USER are required")
	}

	conn := clickhouse.OpenDB(&clickhouse.Options{
		Addr:     []string{host},
		Protocol: clickhouse.HTTP,
		TLS:      &tls.Config{},
		Auth: clickhouse.Auth{
			Username: user,
			Password: password,
		},
	})
	defer conn.Close()

	ctx := context.Background()

	// Get raw_ prefixed tables
	rows, err := conn.QueryContext(ctx, `
		SELECT database, name 
		FROM system.tables 
		WHERE database NOT IN ('system', 'information_schema', 'INFORMATION_SCHEMA')
		  AND (name LIKE 'raw_%' OR name = 'sync_watermark' OR name = 'chain_status')
		ORDER BY database, name
	`)
	if err != nil {
		log.Fatal("Failed to query tables:", err)
	}
	defer rows.Close()

	var schemas []string
	for rows.Next() {
		var database, table string
		if err := rows.Scan(&database, &table); err != nil {
			log.Fatal("Failed to scan row:", err)
		}

		// Get CREATE TABLE statement
		var createStmt string
		row := conn.QueryRowContext(ctx, fmt.Sprintf("SHOW CREATE TABLE `%s`.`%s`", database, table))
		if err := row.Scan(&createStmt); err != nil {
			log.Printf("Failed to get schema for %s.%s: %v", database, table, err)
			continue
		}

		schemas = append(schemas, fmt.Sprintf("-- %s.%s\n%s;\n", database, table, createStmt))
	}

	if err := rows.Err(); err != nil {
		log.Fatal("Row iteration error:", err)
	}

	header := "-- Auto-generated by cmd/remoteschema/schema.go - DO NOT EDIT\n\n"
	output := header + strings.Join(schemas, "\n")
	if err := os.WriteFile("remote_schema.sql", []byte(output), 0644); err != nil {
		log.Fatal("Failed to write remote_schema.sql:", err)
	}

	fmt.Printf("Exported %d table schemas to remote_schema.sql\n", len(schemas))
}
